"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDateTimeWithPattern = exports.formatDateTime = void 0;
const DATE_TIME_FORMATTING_SYSTEM_OPTIONS = Intl.DateTimeFormat().resolvedOptions();
// Constants for implementing the function to format date time (format with pattern)
const TOKEN_OPTION_MAPPINGS = {
    w: 'narrow',
    ww: 'short',
    www: 'long',
    d: 'numberic',
    dd: '2-digit',
    m: 'numeric',
    mm: '2-digit',
    mmm: 'narrow',
    mmmm: 'short',
    mmmmm: 'long',
    yy: '2-digit',
    yyyy: 'numeric',
    h: 'numeric',
    hh: '2-digit',
    H: 'numeric',
    HH: '2-digit',
    M: 'numeric',
    MM: '2-digit',
    s: 'numeric',
    ss: '2-digit',
    S: 3,
    t: 'shortOffset',
    tt: 'longOffset',
};
const INVALID_CHARACTER_PATTERN_REGEX_VALIDATOR = /[^\s\/\-:,wymdhHMsSpt]/;
const DATETIME_TOKEN_REGEX_VALIDATORS = {
    weekday: /www|ww|w/g,
    day: /dd|d/g,
    month: /mmmmm|mmmm|mmm|mm|m/g,
    year: /yyyy|yy/g,
    hour: /hh|h|HH|H/g,
    minute: /MM|M/g,
    second: /ss|s/g,
    fractionalSecond: /S/g,
    timeZoneName: /tt|t/g,
    dayPeriod: /p/g,
};
// reuse date time formatter (format with pattern) => avoid creating too much instances
const dateTimeFormatterStorage = {};
const getDateTimeFormatter = (locale, options) => {
    const key = locale + JSON.stringify(options);
    if (!dateTimeFormatterStorage[key]) {
        dateTimeFormatterStorage[key] = new Intl.DateTimeFormat(locale, options);
    }
    return dateTimeFormatterStorage[key];
};
/**
 *
 * @param inputDate - An input of date (Date, number or string).
 * @param locale - Language code or locale (Ex: `'vi'`, `'vi-VN'`).
 * - Default: `'vi'`
 * @param options
 * - Default: an object with the following options
 * @param options.timeZone - The time zone that the output date string is rendered.
 * - Default: system time zone
 * @param options.hour12 - A boolean option to display hour.
 * - Default: `false`
 * - `true`: 15:00:00 => 03:00:00 PM (en), 03:00:00 CH (vi)
 * - `false`: 15:00:00 => 15:00:00
 * @param options.year
 * - Default: `numeric`
 * - `numeric`: 2023 => 2023
 * - `2-digit`: 2023 => 23
 * @param options.month
 * - Default: `2-digit`
 * - `numeric`: 09 => 09
 * - `2-digit`: 09 => 9
 * - `long`: 09 => 'September'
 * - `short`: 09 => 'Sep'
 * - `narrow`: 09 => 'S'
 * @param options.day
 * - Default: `2-digit`
 * - `numeric`: 09 => 09
 * - `2-digit`: 09 => 9
 * @param options.hour
 * - Default: `2-digit`
 * - `numeric`: 09 => 09
 * - `2-digit`: 09 => 9
 * @param options.minute
 * - Default: `2-digit`
 * - `numeric`: 09 => 09
 * - `2-digit`: 09 => 9
 * @param options.second
 * - Default: `2-digit`
 * - `numeric`: 09 => 09
 * - `2-digit`: 09 => 9
 * @param options.weekday
 * - Default: `undefined`
 * - `long`: Monday => Monday
 * - `short`: Monday => Mon
 * - `narrow`: Monday => M
 *
 * @returns A formatted date string in a specific language; returns `undefined` if `value` doesn't present an invalid date.
 *
 */
const formatDateTime = (inputDate, locale = 'vi', options = {
    timeZone: DATE_TIME_FORMATTING_SYSTEM_OPTIONS.timeZone,
    hour12: false,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
}) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    try {
        const date = new Date(inputDate);
        // invalid date
        if (Number.isNaN(date.getTime())) {
            return undefined;
        }
        const safeLocale = locale !== null && locale !== void 0 ? locale : 'vi';
        const safeOptions = {
            timeZone: (_a = options.timeZone) !== null && _a !== void 0 ? _a : DATE_TIME_FORMATTING_SYSTEM_OPTIONS.timeZone,
            hour12: (_b = options.hour12) !== null && _b !== void 0 ? _b : false,
            year: (_c = options.year) !== null && _c !== void 0 ? _c : 'numeric',
            month: (_d = options.month) !== null && _d !== void 0 ? _d : '2-digit',
            day: (_e = options.day) !== null && _e !== void 0 ? _e : '2-digit',
            hour: (_f = options.hour) !== null && _f !== void 0 ? _f : '2-digit',
            minute: (_g = options.minute) !== null && _g !== void 0 ? _g : '2-digit',
            second: (_h = options.second) !== null && _h !== void 0 ? _h : '2-digit',
            weekday: options.weekday,
            fractionalSecondDigits: options.fractionalSecondDigits,
            timeZoneName: options.timeZoneName,
        };
        return date.toLocaleString(safeLocale, safeOptions);
    }
    catch (_j) {
        return undefined;
    }
};
exports.formatDateTime = formatDateTime;
/**
 * A formatted date string in a specific language and pattern; returns `undefined` if `inputDate` doesn't present an invalid date or `pattern` is invalid.
 *
 * @param inputDate - An input of date (Date, number or string).
 * @param pattern - A pattern to format date time (describe as below).
 * @param locale - Language code or locale (Ex: `'vi'`, `'vi-VN'`).
 * - Default: `'vi'`
 * @param timeZone - The time zone that the output date string is rendered.
 * - Default: system time zone
 *
 *
 * // WEEKDAY: Monday
 * - w: M
 * - ww: Mon
 * - www: Monday
 *
 * // DAY: 7
 * - d: 7
 * - dd: 07
 *
 * // MONTH: 9
 * - m: 9
 * - mm: 09
 * - mmm: S
 * - mmmm: Sep
 * - mmmmm: September
 *
 * // YEAR: 2023
 * - yy: 23
 * - yyyy: 2023
 *
 * // HOUR: 9
 * - h: 9, (12-hour format)
 * - hh: 09, (12-hour format)
 * - H: 9, (24-hour format)
 * - HH: 09, (24-hour format)
 *
 * // MINUTE: 9
 * - M: 9
 * - MM: 09
 *
 * // SECOND: 9
 * - s: 9
 * - ss: 09
 *
 * // MICROSECONDS: 99 (3-digit)
 * - S: 099
 *
 * // TIMEZONE OFFSET: GMT+7
 * - t: GMT+7
 * - tt: GMT+07:00
 *
 * // DAY PERIOD (only affected for 12-hour format)
 * - p: AM (en), SH (vi)
 *
 */
const formatDateTimeWithPattern = (inputDate, pattern, locale = 'vi', timeZone = DATE_TIME_FORMATTING_SYSTEM_OPTIONS.timeZone) => {
    var _a;
    try {
        const date = new Date(inputDate);
        const safeLocale = locale !== null && locale !== void 0 ? locale : 'vi';
        // - contains yyy
        // - contains y{5}, y{6},... (++)
        const invalidYearPattern = (/yyy/.test(pattern) && !/yyyy/.test(pattern)) || /yyyyy/.test(pattern);
        // satify one of five the following conditions => ERROR
        // - invalid date
        // - missing locale
        // - blank string
        // - contains invalid characters in pattern
        // - `invalidYearPattern`
        if (Number.isNaN(date.getTime()) ||
            !safeLocale ||
            !pattern.trim() ||
            INVALID_CHARACTER_PATTERN_REGEX_VALIDATOR.test(pattern) ||
            invalidYearPattern) {
            return undefined;
        }
        // validates pattern and finds all matched tokens
        const matchedTokens = {};
        for (const key in DATETIME_TOKEN_REGEX_VALIDATORS) {
            const matched = pattern.match(DATETIME_TOKEN_REGEX_VALIDATORS[key]);
            if (matched) {
                if (matched.length !== 1)
                    return undefined;
                const token = matched[0];
                matchedTokens[key] = token;
                // replace `token` to `{{token}}` => replace correctly value by token
                // Example:
                // - Incorrect: 'www t' => 'Chủ nhậGMT+7'
                // - Correct: 'www t' => 'Chủ nhật GMT+7'
                pattern = pattern.replace(token, '{{' + token + '}}');
            }
        }
        // `dayPeriod` is only allowed to use in 12-hour format
        if (((_a = matchedTokens['hour']) === null || _a === void 0 ? void 0 : _a.startsWith('H')) && matchedTokens['dayPeriod']) {
            return undefined;
        }
        // infers token to option values for creating formatter
        const weekday = matchedTokens['weekday'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['weekday']] : undefined;
        const year = matchedTokens['year'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['year']] : undefined;
        const month = matchedTokens['month'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['month']] : undefined;
        const day = matchedTokens['day'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['day']] : undefined;
        const hour = matchedTokens['hour'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['hour']] : undefined;
        const minute = matchedTokens['minute'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['minute']] : undefined;
        const second = matchedTokens['second'] ? TOKEN_OPTION_MAPPINGS[matchedTokens['second']] : undefined;
        const hour12 = matchedTokens['hour'] ? matchedTokens['hour'].startsWith('h') : false;
        const fractionalSecondDigits = matchedTokens['fractionalSecond']
            ? TOKEN_OPTION_MAPPINGS[matchedTokens['fractionalSecond']]
            : undefined;
        const timeZoneName = matchedTokens['timeZoneName']
            ? TOKEN_OPTION_MAPPINGS[matchedTokens['timeZoneName']]
            : undefined;
        // prettier-ignore
        const options = { weekday, year, month, day, hour, minute, second, fractionalSecondDigits, hour12, timeZoneName, timeZone };
        const formatter = getDateTimeFormatter(locale, options);
        const parts = formatter.formatToParts(date);
        const partsInObject = {};
        for (const part of parts) {
            if (part.type !== 'literal') {
                partsInObject[part.type] = part.value;
            }
        }
        let formattedDate = pattern;
        for (const key in matchedTokens) {
            formattedDate = formattedDate.replace('{{' + matchedTokens[key] + '}}', partsInObject[key]);
        }
        return formattedDate;
    }
    catch (_b) {
        return undefined;
    }
};
exports.formatDateTimeWithPattern = formatDateTimeWithPattern;
//# sourceMappingURL=datetime.js.map